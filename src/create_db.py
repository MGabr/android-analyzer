from textwrap import dedent

from src.models.certificate import Certificate
from src.models.scenario_settings import ScenarioSettings
from src.app import db
from src.models.vuln_type import VulnType


def create_db():
    db.create_all()


def fill_db():
    _add_default_settings()


def drop_db():
    db.drop_all()


def _add_default_settings():
    mitmproxy_ca_signed = Certificate(
        name='Signed on-the-fly by unknown CA',
        description=dedent('''
        This is a not expired, on-the-fly generated certificate with the right hostname.
        It is signed by the mitmproxy default certificate authority.
        '''))

    other_hostname_self_signed = Certificate(
        name='Self-signed with fixed hostname',
        description=dedent('''
        This is a not expired certificate with a fixed hostname (*.mitmproxy.org).
        It is self signed.
        '''),
        custom_cert="default/other_hostname_self_signed.pem")

    untrusted_ca = Certificate(
        name='Signed on-the-fly by an untrusted CA',
        description=dedent('''
        This is a not expired, on-the-fly generated certificate with the right hostname.
        It is signed by an untrusted certificate authority.
        '''),
        custom_ca="default/ca.pem")

    db.session.add(mitmproxy_ca_signed)
    db.session.add(other_hostname_self_signed)
    db.session.add(untrusted_ca)

    db.session.flush()

    mitmproxy_ca_signed_tm = ScenarioSettings(
        vuln_type=VulnType.trust_manager,
        mitm_certificate=mitmproxy_ca_signed,
        info_message='''The app has a vulnerable TrustManager implementation and a man-in-the-middle attack with a certificate generated by a untrusted certificate authority (but otherwise valid) was possible.''')

    other_hostname_self_signed_hv = ScenarioSettings(
        vuln_type=VulnType.hostname_verifier,
        mitm_certificate=other_hostname_self_signed,
        info_message='''The app has a vulnerable HostnameVerifier implementation and a man-in-the-middle attack with a self signed certificate with another hostname (*.mitmproxy.org) was possible.''')

    no_pinning_hv = ScenarioSettings(
        vuln_type=VulnType.hostname_verifier,
        mitm_certificate=untrusted_ca,
        sys_certificates=[untrusted_ca],
        info_message='''The app has a possibly vulnerable HostnameVerifier implementation and certificate pinning is not implemented.''')

    mitmproxy_ca_signed_wv = ScenarioSettings(
        vuln_type=VulnType.web_view_client,
        mitm_certificate=mitmproxy_ca_signed,
        info_message='''The app has a vulnerable WebViewClient implementation and a man-in-the-middle attack with a certificate generated by a untrusted certificate authority (but otherwise valid) was possible.''')

    mitmproxy_self_signed_wv = ScenarioSettings(
        vuln_type=VulnType.web_view_client,
        mitm_certificate=other_hostname_self_signed,
        info_message='''The app has a vulnerable WebViewClient implementation and a man-in-the-middle attack with a self signed certificate with another hostname (*.mitmproxy.org) was possible.''')

    db.session.add(mitmproxy_ca_signed_tm)
    db.session.add(other_hostname_self_signed_hv)
    db.session.add(no_pinning_hv)
    db.session.add(mitmproxy_ca_signed_wv)
    db.session.add(mitmproxy_self_signed_wv)

    db.session.commit()


# # TODO: Many cases still to do:
#
# mitmproxy_self_signed = Certificate(
#     '',
#     '''
#     This is a not expired, on-the-fly generated certificate with the right hostname.
#     It is self signed.
#     ''')  # TODO: how to generate such certificates on the fly? search all https URLs in static analysis?
#
# expired_ca_signed = Certificate(
#     '',
#     '''
#     This is an expired, on-the-fly generated certificate with the right hostname.
#     It is signed by a trusted certificate authority.
#     ''')  # TODO: is this even possible??
# expired_self_signed = Certificate(
#     '',
#     '''
#     This is an expired, on-the-fly generated certificate with the right hostname.
#     It is self signed.
#     ''')  # TODO: how to generate such certificates on the fly? search all https URLs in static analysis?
#
# other_hostname_ca_signed = Certificate(
#     '',
#     '''
#     This is a not expired certificate with a fixed hostname (*.mitmproxy.org).
#     It is signed by a trusted certificate authority.
#     ''',
#     custom_cert="mitmproxy/other_hostname_ca_signed.pem")  # TODO: how to get a certificate from a trusted CA?
#
# other_hostname_ca_signed_expired = Certificate(
#     '',
#     '''
#     This is an expired certificate with a fixed hostname (*.mitmproxy.org).
#     It is signed by a trusted certificate authority.
#     ''')  # TODO: how to get a certificate from a trusted CA
# other_hostname_self_signed_expired = Certificate(
#     '',
#     '''
#     This is an expired certificate with a fixed hostname (*.mitmproxy.org).
#     It is self signed.
#     ''',
#     custom_cert="mitmproxy/other_hostname_self_signed_expired.pem")  # TODO: generate certificate with 1 day expiration?
#
# # TODO: user installed certificates

if __name__ == "__main__":
    add_default_settings()
